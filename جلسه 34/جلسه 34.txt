اول Authentication و Authorisation رو توضیح بدم و تفاوتشون رو بگم.
بعد توضیح بدم که جنگو برای سطح دسترسی از میکسین ها استفاده کرده و ارث بری چند گانه رو بگم. (ولی ترجیحا تا زمانی که لازم نشد استفاده نکنیم تو پایتون.)
چون خرابکاری میکنه و مشکل به وجود میاره تو خیلی از زبان ها هم نیست ارث بری چند گانه اصلا.
خلاصه:
from django.contrib.auth.mixins import LoginRequiredMixin
و تو قسمت لاگین حتما قبل از اون یکی ازش ارث بری کنه. یعنی:
class BookCreateView(LoginRequiredMixin, generic.CreateView):
که برای لاگین میخواد که لاگین کرده باشیم. یو آر الش رو هم به بچه ها نشون بدم و توضیح بدم که میگه بعد از لاگین به کجا بره و خودش همه رو هندل کرده.
برای صفحه آپدیت و پاک کردن هم قاعدتا لازم هست و برای اونا هم بذاریم.
نکته آخر این که شاید بچه ها بگن لینک رو اگه لاگین نکرده بود نشون ندیم. درسته که لینک نیست.
اما تابعش (یا کلاسش) رو نوشتیم و اگر به هر طریقی کاربر یو آر ال رو وارد کنه اون طوری میتونه هک کنه. اما وقتی میکسین میذاریم دیگه نمیتونه.
میکسین مال شی گرایی و کلاس هست.
برای تابع، از دکوریتور استفاده میکنیم.
from django.contrib.auth.decorators import login_required
و بعد این خط رو قبل از تابعمون میذاریم.
@login_required
بعد از این قسمت، تو مدل کتاب، یوزر ایجاد کننده کتاب رو هم اضافه کنیم.
و این که اطلاعات هر کتاب رو کی اضافه کرده ذخیره کنیم.
بعد عوض کنیم.
هدف اینه که هر کسی که کتابی رو گذاشته، خودش بتونه ویرایش یا حذفش کنه. (از رو همین بچه ها باید بتونن
خودشون کامنت رو هم درست کنن که کسی ویرایش یا حذف کنه کامنت خودش رو.)
اما در حالت فعلی همه میتونن.
پس میریم که این قسمت رو هم درست کنیم هر کسی فقط توانایی تغییر ارسالی های خودش رو داشته باشه.
این رو هم اضافه میکنیم.
UserPassesTestMixin
یعنی میشه این شکلی:
from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin
خب حالا میریم کلاس آپدیتمون رو کامل ترش میکنیم. مینویسیم.
class BookUpdateView(LoginRequiredMixin, UserPassesTestMixin, generic.UpdateView):
که تریتیب هم باید رعایت بشه. اول باید لاگین کرده باشه. بعد تستش میکنیم که لیاقت داره یا نه :D و بعد هم از جنریک آپدیت ویو رو میاریم.
خلاصه وقتی این رو میذاریم، یه ابسترکت کلاس هست و باید تابع test_func رو overide ش کنیم حتما.
داخل تابع آپدیت، ما یه چیزی رو میخوایم آپدیت کنیم دیگه :دی. با سلف.گت آبجکت میتونیم اون رو بخوونیم که چی هست.
از طرفی چون داخل کلاس هستیم، برای دسترسی به کسی که درخواست رو داده و request رو ارسال کرده، از سلف استفاده میکنیم.
تو خود جنگو توی کلاس ها، رکوئست رو هم ذخیره کردن.
تابع رو به این صورت داخلش مینویسیم:
def test_func(self):
	obj = self.get_object()
	return obj.user == self.request.user
و اگه خودش نباشه بهش اجازه نمیده. در واقع هر جور که دلمون بخواد داخلش رو میتونیم بنویسیم.


پایان پروژه.
کامنت رو بچه ها دیگه خودشون درست کنن.







اگه فرصت کردم برای دیدن جزییات از لاگین مدل فانکشنال استفاده کردیم
. ببینم میکسین این که یوزر خودش باشه چه جوری هست. البته لزومی نداره ها
. و ننویسم. فقط تست کنم ببینم چه طوری میشه نوشت تو فانکشنال ویو.
اینا رو که انجام دادم پاک کنم این رو.
